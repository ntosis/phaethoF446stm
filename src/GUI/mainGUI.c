/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "Ctrl_Subsystem.h"
#include "guiLibs/DIALOG.h"
#include "rtc.h"
#include "spi.h"
#include "mainGUI.h"

WM_HWIN hWin;
struct AMessage *rxMessage;
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0  (GUI_ID_USER + 0x00)
#define ID_BUTTON_0  (GUI_ID_USER + 0x01)
#define ID_BUTTON_1  (GUI_ID_USER + 0x02)
#define ID_SPINBOX_0  (GUI_ID_USER + 0x03)
#define ID_TEXT_0  (GUI_ID_USER + 0x04)
#define ID_IMAGE_0  (GUI_ID_USER + 0x05)
#define ID_EDIT_0 (GUI_ID_USER + 0x88)
#define ID_IMAGE_0_IMAGE_0  0x00

int id_edit_0 = (GUI_ID_USER + 0x88);
// USER START (Optionally insert additional defines)
//
// Colors
//
#define DARK_BLUE   0x613600
#define LIGHT_BLUE  0xaa7d67
#define BLUE        0x855a41
#define LEMON       0x00d6d3
#define MAX_TEMPERATURE  30
#define MIN_TEMPERATURE   2
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
/*********************************************************************
*
*       _acImage_0, "BMP", ID_IMAGE_0_IMAGE_0
*/
/*********************************************************************
*
*       _aGradient
*/
static const GUI_COLOR _aGradient[] = {
  0x00BC944C, 0x00BC944C, 0x00BB944C, 0x00BA944C, 0x00BA944C, 0x00B9944C, 0x00B9944C, 0x00B8944C, 0x00B7944C, 0x00B7944C, 0x00B6944C, 0x00B5944C, 0x00B5944C, 0x00B4944C, 0x00B3944C, 0x00B3944C, 0x00B2944C, 0x00B1944C, 0x00B0944C, 0x00AF944C, 0x00AE944C,
  0x00AE944C, 0x00AD944C, 0x00AC944C, 0x00AB944C, 0x00AA944C, 0x00A9944C, 0x00A8944C, 0x00A7944C, 0x00A6944C, 0x00A5944C, 0x00A4944C, 0x00A3944C, 0x00A2944C, 0x00A1944C, 0x00A0944C, 0x009F944C, 0x009E944C, 0x009D944C, 0x009C944C, 0x009B944C,
  0x009A944C, 0x0099944C, 0x0098944C, 0x0097944C, 0x0096944C, 0x0094944C, 0x0093944C, 0x0092944C, 0x0091944C, 0x0090944C, 0x008F944C, 0x008E944C, 0x008C944C, 0x008B944C, 0x008A944C, 0x0089944C, 0x0088944C, 0x0087944C, 0x0085944C, 0x0084944C,
  0x0083944C, 0x0082944C, 0x0081944C, 0x007F944C, 0x007E944C, 0x007D944C, 0x007C944C, 0x007B944C, 0x0079944C, 0x0078944C, 0x0077944C, 0x0076944C, 0x0075944C, 0x0074944C, 0x0072944C, 0x0071944C, 0x0070944C, 0x006F944C, 0x006E944C, 0x006D944C,
  0x006B944C, 0x006A944C, 0x0069944C, 0x0068944C, 0x0067944C, 0x0066944C, 0x0065944C, 0x0063944C, 0x0062944C, 0x0061944C, 0x0060944C, 0x005F944C, 0x005E944C, 0x005D944C, 0x005C944C, 0x005B944C, 0x005A944C, 0x0059944C, 0x0058944C, 0x0057944C,
  0x0056944C, 0x0055944C, 0x0054944C, 0x0053944C, 0x0052944C, 0x0051944C, 0x0050944C, 0x004F944C, 0x004E944C, 0x004D944C, 0x004C944C, 0x004C944C, 0x004B944C, 0x004A944C, 0x0049944C, 0x0048944C, 0x0047944C, 0x0047944C, 0x0046944C, 0x0045944C,
  0x0044944C, 0x0044944C, 0x0043944C, 0x0042944C, 0x0042944C, 0x0041944C, 0x0041944C, 0x0040944C, 0x003F944D, 0x003F944D, 0x003E944E, 0x003E944F, 0x003D934F, 0x003D9350, 0x003C9351, 0x003C9352, 0x003B9352, 0x003B9353, 0x003A9354, 0x003A9355,
  0x00399256, 0x00399256, 0x00399257, 0x00389258, 0x00389259, 0x0037925A, 0x0037915B, 0x0037915C, 0x0036915D, 0x0036915E, 0x0035915F, 0x00359160, 0x00359061, 0x00349062, 0x00349063, 0x00349064, 0x00339066, 0x00338F67, 0x00338F68, 0x00338F69,
  0x00328F6A, 0x00328F6B, 0x00328E6D, 0x00328E6E, 0x00318E6F, 0x00318E70, 0x00318D71, 0x00318D73, 0x00308D74, 0x00308D75, 0x00308D77, 0x00308C78, 0x00308C79, 0x002F8C7A, 0x002F8C7C, 0x002F8B7D, 0x002F8B7E, 0x002F8B80, 0x002E8B81, 0x002E8A82,
  0x002E8A84, 0x002E8A85, 0x002E8A86, 0x002E8988, 0x002E8989, 0x002D898A, 0x002D898C, 0x002D888D, 0x002D888F, 0x002D8890, 0x002D8891, 0x002D8893, 0x002D8794, 0x002D8795, 0x002C8797, 0x002C8798, 0x002C869A, 0x002C869B, 0x002C869C, 0x002C869E,
  0x002C859F, 0x002C85A0, 0x002C85A2, 0x002C85A3, 0x002C84A4, 0x002C84A6, 0x002C84A7, 0x002C84A8, 0x002B83AA, 0x002B83AB, 0x002B83AC, 0x002B83AD, 0x002B82AF, 0x002B82B0, 0x002B82B1, 0x002B82B3, 0x002B82B4, 0x002B81B5, 0x002B81B6, 0x002B81B7,
  0x002B81B9, 0x002B80BA, 0x002B80BB, 0x002B80BC, 0x002B80BD, 0x002B80BE, 0x002B7FC0, 0x002B7FC1, 0x002B7FC2, 0x002B7FC3, 0x002A7FC4, 0x002A7EC5, 0x002A7EC6, 0x002A7EC7, 0x002A7EC8, 0x002A7EC9, 0x002A7ECA, 0x002A7DCB, 0x002A7DCC, 0x002A7DCD,
  0x002A7DCE, 0x002A7DCE, 0x002A7DCF, 0x002A7CD0, 0x002A7CD1, 0x002A7CD2, 0x002A7CD2, 0x002A7CD3, 0x002A7CD4, 0x00297CD5, 0x00297CD5, 0x00297BD6, 0x00297BD7, 0x00297BD7, 0x00297BD8
};
static const U8 _acImage_0[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};
extern GUI_CONST_STORAGE GUI_BITMAP bmp_button_green;
extern GUI_CONST_STORAGE GUI_BITMAP bmp_button_red;
extern GUI_CONST_STORAGE GUI_BITMAP bmp_button_auto_green;
extern GUI_CONST_STORAGE GUI_BITMAP bmp_button_auto_black;

// USER START (Optionally insert additional static data)
static int stateONOFF=0;
static int stateAUTOMAN=0;
extern bool clicked;
extern int16_t inputValue_Htng;
extern int16_t inputValue_Coolg;
//
// Set pointer to a font, used for an easier exchange of fonts
//
static GUI_CONST_STORAGE GUI_FONT * pFont23pBold = &GUI_Font24B_ASCII;
static GUI_CONST_STORAGE GUI_FONT * pFont32pBold = &GUI_Font32B_ASCII;
static GUI_CONST_STORAGE GUI_FONT * pFont23p     = &GUI_Font24_ASCII;
static GUI_CONST_STORAGE GUI_FONT * pFont32p     = &GUI_Font32_ASCII;
// USER END
/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 480, 320, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "OnOff", ID_BUTTON_0, 32, 10, 60, 60, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "AutoMan", ID_BUTTON_1, 32, 80, 60, 60, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "Edit", ID_EDIT_0, 32, 164, 100, 39, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Text", ID_TEXT_0, 155, 76, 160, 160, 0, 0x0, 0 },
  { IMAGE_CreateIndirect, "Led", ID_IMAGE_0, 102, 95, 30, 30, 0, 0, 0 },
  // USER START (Optionally insert additional widgets)

  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _GetImageById
*/
static const void * _GetImageById(U32 Id, U32 * pSize) {
  switch (Id) {
  case ID_IMAGE_0_IMAGE_0:
    *pSize = sizeof(_acImage_0);
    return (const void *)_acImage_0;
  }
  return NULL;
}

// USER START (Optionally insert additional static code)
/*********************************************************************
*
*       _cbButton
*
* Function description:
*  This is the callback function for the buttons which represent the
*  different rooms.
*
*/
static void _cbText(WM_MESSAGE * pMsg) {
    int8_t tmep;
	 /* struct AMessage *pxRxedMessage;
	  if(xQueueReceive( xQueueCtrlSubsystem, &( pxRxedMessage ), ( TickType_t ) 10 )) {
	       tmep = pxRxedMessage->SOLLtemperature;
	  }
	  else {
	      tmep=126;
	  }
	  */

    char buff[20];
  GUI_RECT Rect;
  GUI_COLOR ColorFrame;
  GUI_COLOR Color;
  GUI_COLOR ColorText;
  GUI_CONST_STORAGE GUI_FONT * pFont23;
  GUI_CONST_STORAGE GUI_FONT * pFont32;

  switch (pMsg->MsgId) {
  case WM_PAINT:

      GUI_Clear();
      Color = DARK_BLUE;
      ColorText = GUI_WHITE;
      ColorFrame = GUI_WHITE;
      pFont23 = pFont23p;
      pFont32 = pFont32p;
    //
    // Draw thin frame around the button
    //
    WM_GetClientRectEx(pMsg->hWin, &Rect);
    GUI_SetColor(ColorFrame);
    GUI_FillRectEx(&Rect);
    GUI_SetColor(Color);
    //
    // Resize drawing rect
    //
    Rect.x0 += 1;
    Rect.x1 -= 1;
    Rect.y1 -= 1;
    //
    // Draw rest of the button
    //
    GUI_AA_FillRoundedRectEx(&Rect, 3);

    //
    // Draw Text
    //
    GUI_SetFont(&GUI_Font16_ASCII);
    GUI_SetColor(ColorText);
    GUI_SetTextAlign(GUI_TA_LEFT | GUI_TA_VCENTER);
    GUI_GotoXY(Rect.x0, Rect.y0+20);
    GUI_DispString("On/Off");
	    GUI_GotoXY(Rect.x0+80, Rect.y0+20);
	    GUI_DispDecSpace(/*stateOfProgram*/1, 1);
    GUI_GotoXY(Rect.x0, Rect.y0+40);
    GUI_DispString("Man/Auto");
	    GUI_GotoXY(Rect.x0+80, Rect.y0+40);
            GUI_DispDecSpace(/*selectProgram*/1, 2);
    GUI_GotoXY(Rect.x0, Rect.y0+60);
    GUI_DispString("PID_H");
	    GUI_GotoXY(Rect.x0+80, Rect.y0+60);
            GUI_DispDecSpace(inputValue_Htng, 2);
    GUI_GotoXY(Rect.x0, Rect.y0+80);
    GUI_DispString("PID_C");
	    GUI_GotoXY(Rect.x0+80, Rect.y0+80);
            GUI_DispDecSpace(inputValue_Coolg, 2);
    GUI_GotoXY(Rect.x0, Rect.y0+100);
    GUI_DispString("Temp.");
    GUI_GotoXY(Rect.x0+80, Rect.y0+100);
    GUI_DispDecSpace(tmep, 4);//f446 migration replace 20 with Temperature
    GUI_GotoXY(Rect.x0, Rect.y0+120);
    GUI_DispString("Time");
    GUI_GotoXY(Rect.x0+80, Rect.y0+120);
    Show_RTC_Calendar();
    sprintf(buff,"%d:%d:%d",tm.Hour,tm.Minute,tm.Second);
    GUI_DispString(buff);




    //
    // Display temperature with a bigger font
    //
    int Index = ((SOLLtemperature - MIN_TEMPERATURE) * (GUI_COUNTOF(_aGradient) - 1)) / (MAX_TEMPERATURE - MIN_TEMPERATURE);
    Color = _aGradient[Index];
   // GUI_SetColor(Color);
    //GUI_SetBkColor(Color);
    //GUI_Clear();
    //GUI_SetColor(GUI_WHITE);
    /*GUI_SetFont(pFont32);
    GUI_SetTextAlign(GUI_TA_RIGHT | GUI_TA_VCENTER);
    GUI_GotoXY(Rect.x1 - 20, Rect.y1 / 2);
    GUI_DispDecSpace(SOLLtemperature, 2);
    GUI_DispString("�C");*/


    break;
  default:
    TEXT_Callback(pMsg); // The original callback
    break;
  }
}


static void _cbBMPButton(WM_MESSAGE * pMsg) {
  GUI_RECT Rect;
  int Index;

  switch (pMsg->MsgId) {
  case WM_PAINT:
    WM_GetClientRectEx(pMsg->hWin, &Rect);
    if(stateONOFF){
      GUI_DrawBitmap(&bmp_button_green, 0, 0);
    } else {
      GUI_DrawBitmap(&bmp_button_red, 0, 0);
    }
    break;
  default:
    BUTTON_Callback(pMsg); // The original callback
    break;
  }
}

static void _cbAutoManButton(WM_MESSAGE * pMsg) {
  GUI_RECT Rect;
  int Index;

  switch (pMsg->MsgId) {
  case WM_PAINT:
    WM_GetClientRectEx(pMsg->hWin, &Rect);
    if(stateAUTOMAN){
      GUI_DrawBitmap(&bmp_button_auto_green, 0, 0);
    } else {
      GUI_DrawBitmap(&bmp_button_auto_black, 0, 0);
    }
    break;
  default:
    BUTTON_Callback(pMsg); // The original callback
    break;
  }
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  const void * pData;
  WM_HWIN      hItem;
  U32          FileSize;
  int          NCode;
  int          Id;
  static WM_HTIMER hTimer;

  // USER START (Optionally insert additional variables)

  // USER END

  switch (pMsg->MsgId) {

  case WM_INIT_DIALOG:
    hItem = pMsg->hWin;
    //Init Timer
    hTimer = WM_CreateTimer(hItem, 0, 2000, 0);

    //
    // Initialization of 'Window'
    //
    WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(0x00040404));
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
    EDIT_SetText(hItem, "");
    //
    // Initialization of 'OnOff'
    //
    //hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    //BUTTON_SetText(hItem, "On/Off");
    //
    // Initialization of 'AutoMan'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
    //BUTTON_SetText(hItem, "Auto/Man");
    WM_SetCallback(hItem, _cbAutoManButton);
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    WM_SetCallback(hItem, _cbText);
    //TEXT_SetFont(hItem, GUI_FONT_13_1);
    //TEXT_SetTextColor(hItem, GUI_MAKE_COLOR(0x00000000));
    //
    // Initialization of 'SpinBox'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_0);
    SPINBOX_SetFont(hItem, GUI_FONT_20B_ASCII);
    SPINBOX_SetRange(hItem,-35,35);
    SPINBOX_SetValue(hItem,1);//f446 migration SOLLtemperature);

    //
    // Initialization of 'Led'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_0);
    pData = _GetImageById(ID_IMAGE_0_IMAGE_0, &FileSize);
    IMAGE_SetBMP(hItem, pData, FileSize);
    //IMAGE_SetBitmap(hItem, &bmp_button_pressed);
    // USER START (Optionally insert additional code for further widget initialization)
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    WM_SetCallback(hItem, _cbBMPButton);
    // USER END
    break;
    case WM_TOUCH:
    //
    // If we touch somewhere on the screnn the keyboard gets hidden
    //
    WM_HideWindow(_hKeyboard);
    break;
  case WM_TIMER:
      //Refresh Text
      WM_InvalidateWindow(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0));
      WM_RestartTimer(pMsg->Data.v, 2000);
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'OnOff'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)

		stateONOFF^=1;
		/*stateOfProgram ^=1;*/ //Move from Ctrl_Subsystem line 91, change it in Matlab
	  	clicked=stateONOFF;
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'AutoMan'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
	  /*if(stateOfProgram) {
	  stateAUTOMAN ^=1;
	  selectProgram ^=1;
	  doubleClicked=stateAUTOMAN;
	  }*/
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
      case ID_EDIT_0: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        //
        // After a click inside the edit widget, we show the keyboard
        //
        WM_ShowWindow(_hKeyboard);
        break;
      }
      break;
    case ID_SPINBOX_0: // Notifications sent by 'Spinbox'

      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
	  WM_InvalidateWindow(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0));
        // USER END
        break;
      case WM_NOTIFICATION_MOVED_OUT:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
	  hItem = WM_GetDialogItem(pMsg->hWin, Id);

        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }

      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow(void);
WM_HWIN CreateWindow(void) {

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);

  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/


void GUI_X_ErrorOut(const char * s) {}

GUI_TIMER_TIME GUI_X_GetTime(void) {
   return xTaskGetTickCount ();
}
void GUITask(void) {
    //GUI_Init();
    //GUI_DrawBitmap(&bmp_button_pressed, 45, 20);
    CreateWindow();
    createKeyboard();


    //while(1){ GUI_Exec();};
}

/*************************** End of file ****************************/
